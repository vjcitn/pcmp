#' find discrete variables in colData
#' @import SingleCellExperiment crosstalk d3scatter dplyr shiny
#' @import Rtsne irlba umap methods
#' @param se instance of SummarizedExperiment; SingleCellExperiment also works
#' @param maxnuv numeric(1) largest number of unique values that may be present in a variable that will be regarded as 'discrete'
#' @return character vector of variable names satisfying discreteness condition
#' @examples
#' discreteColdVars  # need example se
#' @export
discreteColdVars = function(se, maxnuv=25) {
 nuv = sapply(colData(se), function(x) length(unique(x)))
 cdn = names(nuv)
 cdn[ which(nuv>1 & nuv<=maxnuv) ]
}
 

#' create vector of indices constituting a stratified sample using a discrete variable to partition strata
#' @param strata atomic vector
#' @param nperstrat size of sample to be retrieved
#' @note fails if any stratum has size less than 'nperstrat'
#' @return numeric vector of indices
#' @examples
#' mytags = c(1,1,1,2,2,3,1,1,1,2,2,3,3,3,3,2,2,2)
#' mydat = 1:length(mytags)
#' names(mydat) = mytags
#' inds = stratsampInds(mytags, nperstrat=2)
#' mydat[inds]
#' @export
stratsampInds = function(strata, nperstrat=300) {
  levs = unique(strata)
  inds = lapply(levs, function(x) which(strata == x))
  ns = vapply(inds, length, numeric(1))
  stopifnot(all(ns>nperstrat))
  samp = lapply(inds, function(x) sample(x, size=nperstrat))
  sort(unlist(samp))
}

#' schematize a sequence of projection methods
#' @return a list with two components, 'projectors'
#' and 'retrievers'.  'projectors' is a named list of
#'  functions with parameters 'x' and 'ncomp',
#' where the intended usage has 'x' inheriting from SingleCellExperiment, 
#' and 'ncomp' numeric defining the number of projection components
#' to be retained.  'retrievers' is a named list of functions
#' with parameter 'x', which extracts the ncomp x nsamp
#' projection for each method.
#' @note The default sequence is irlba::irlba, umap::umap,
#' Rtsne::Rtsne
#' @examples
#' defaultProjectors
#' @export
defaultProjectors = function() list(
  projectors=list(
   PPCA=function(x, ncomp) {
      if (isTRUE(options()$verbose))
         message("starting irlba at ", date())
      irlba::irlba(x, nv=ncomp)
      },
   UMAP=function(x, ncomp) {
      if (isTRUE(options()$verbose))
         message("starting umap at ", date())
      umap::umap(x, n_components=ncomp)
      },
   TSNE=function(x, ncomp) {
      if (isTRUE(options()$verbose))
         message("starting Rtsne at ", date())
      Rtsne::Rtsne(x, dims=ncomp)
     }
    ),
  retrievers = list(
   PPCA = function(x) x$u,
   UMAP = function(x) x,
   TSNE = function(x) x$Y
    )
   )

.checkDefaultProjectors = function(dp) {
  stopifnot(all(names(dp) == c("projectors", "retrievers")))
  prn = names(dp$projectors)
  ren = names(dp$retrievers)
  stopifnot(all.equal(prn,ren))
}

#' add a series of projectors to transformed assay data
#' in a SingleCellExperiment
#' @param sce SingleCellExperiment instance
#' @param ncomp numeric(1) number of components per projection
#' @param tx function that will transform assay quantifications,
#' defaults to `function(x) log(x+1)`
#' @param projectors a list of list of functions like that created
#' @param \dots not used
#' by `defaultProjectors()`
#' @export
addProjections = function(sce, ncomp=4, tx=function(x) log(x+1),
   projectors, ...) {
  stopifnot(is(sce, "SingleCellExperiment"))
  matToUse = t(tx(assay(sce)))
  prs = lapply(projectors$projectors, function(p) 
      p(x=matToUse, ncomp=ncomp))
  ans = lapply(seq_len(length(prs)), function(i) 
    projectors$retrievers[[i]](prs[[i]])
    )
  ini = reducedDims(sce)
  reducedDims(sce) = SimpleList(c(ini, ans))
  sce
}

#' Define a shiny app for comparing projections
#' @param sce SingleCellExperiment instance with reducedDims populated
#' with various candidates for projection from assay data --
#' currently ignored!  Just uses pcmp::sce300xx
#' @note currently assuming that names(reducedDims) are 'PC', 'UM', 'TS'
#' for projections generated by
#' irlba::irlba, umap::umap, and Rtsne::Rtsne respectively.  Function
#' will delete .pcmpTab, .pcmpSelNum, .pcmpSelCells from .GlobalEnv
#' if found, so that it can assemble information on selections.
#' @export
pcmpApp = function(sce) {
 stores = c(".pcmpTab", ".pcmpSelNum", ".pcmpSelCells")
 sapply(stores, function(x) if(x %in% ls(.GlobalEnv, all=TRUE))
    rm(list=x, envir=.GlobalEnv))
 apd = system.file("app", package="pcmp")
 shiny::runApp(apd)
 list(cells = .GlobalEnv$.pcmpSelCells, limmaTab=.GlobalEnv$.pcmpTab)
}

  
#  if (!quiet) message("starting irlba pca at ", date(), "...")
#  pcs = irlba::irlba(t(tx(assay(se))), nv=ncomp)
#  if (!quiet) message("done; starting umap at ", date(), "...")
#  umapo = uwot::umap(t(tx(assay(se))), n_components=ncomp, ...)
#  if (!quiet) message("done; starting tsne at ", date(), "...")
#  tsno = Rtsne::Rtsne(t(tx(assay(se))), dims=ncomp)
#  if (!quiet) message("done at ", date())
#  nms = c(paste0("PC", 1:ncomp), 
#    paste0("UM", 1:ncomp), paste0("TS", 1:ncomp))
#  ans = cbind(pcs$u, umapo, tsno$Y)
#  colnames(ans) = nms
#  metadata(se)$cproj = as.data.frame(ans)
#  se
#}


#runCproj = function(se, colorby="donor_id") {
#indf = metadata(se)$cproj
#stopifnot(is(indf, "data.frame"))
#ncomp = (ncol(indf))/3  
##indf$strat = colData(se)[[colorby]]
#indf = cbind(indf, as.data.frame(colData(se)))
 
#
##set.seed(1234)
##library("SummarizedExperiment")
##if (!exists("ACCVIS")) load("ACCVIS.rda")
##ACCVIS$strat = paste(ACCVIS$brain_region, ACCVIS$donor_id)
##tokeep = stratsampInds(ACCVIS$strat, 300)
##se = ACCVIS[,tokeep]
##se2 = cproj(se)
#runCproj(se2, colorby="donor_id")

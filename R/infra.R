pkgVersion = function() tail(strsplit(grep("Version", help(package = pcmp)$info[[1]], 
    value = TRUE), " ")[[1]], 1)

#' find discrete variables in colData
#' @import SingleCellExperiment crosstalk d3scatter dplyr shiny
#' @import Rtsne irlba umap methods
#' @importFrom S4Vectors SimpleList
#' @param se instance of SummarizedExperiment; SingleCellExperiment also works
#' @param maxnuv numeric(1) largest number of unique values that may be present in a variable that will be regarded as 'discrete'
#' @return character vector of variable names satisfying discreteness condition
#' @examples
#' discreteColdVars  # need example se
#' @export
discreteColdVars = function(se, maxnuv=25) {
 nuv = sapply(colData(se), function(x) length(unique(x)))
 cdn = names(nuv)
 cdn[ which(nuv>1 & nuv<=maxnuv) ]
}
 

#' create vector of indices constituting a stratified sample using a discrete variable to partition strata
#' @param strata atomic vector
#' @param nperstrat size of sample to be retrieved
#' @note fails if any stratum has size less than 'nperstrat'
#' @return numeric vector of indices
#' @examples
#' mytags = c(1,1,1,2,2,3,1,1,1,2,2,3,3,3,3,2,2,2)
#' mydat = 1:length(mytags)
#' names(mydat) = mytags
#' inds = stratsampInds(mytags, nperstrat=2)
#' mydat[inds]
#' @export
stratsampInds = function(strata, nperstrat=300) {
  levs = unique(strata)
  inds = lapply(levs, function(x) which(strata == x))
  ns = vapply(inds, length, numeric(1))
  stopifnot(all(ns>nperstrat))
  samp = lapply(inds, function(x) sample(x, size=nperstrat))
  sort(unlist(samp))
}

#' schematize a sequence of projection methods
#' @param warmdim numeric(1) defaults to 15 -- defines the dimension
#' reduction using irlba()$u for 'warming up' prior to UMAP or t-SNE runs
#' @return a list with two components, 'projectors'
#' and 'retrievers'.  'projectors' is a named list of
#'  functions with parameters 'x' and 'ncomp',
#' where the intended usage has 'x' inheriting from SingleCellExperiment, 
#' and 'ncomp' numeric defining the number of projection components
#' to be retained.  'retrievers' is a named list of functions
#' with parameter 'x', which extracts the ncomp x nsamp
#' projection for each method.
#' @note The default sequence is irlba::irlba, umap::umap,
#' Rtsne::Rtsne; see the note on `warmdim` parameter.
#' @examples
#' defaultProjectors
#' @export
defaultProjectors = function(warmdim=15) list(
  projectors=list(
   PPCA=function(x, ncomp) {
      if (isTRUE(options()$verbose))
         message("starting irlba at ", date())
      irlba::irlba(x, nv=ncomp)
      },
   UMAP=function(x, ncomp) {
      if (isTRUE(options()$verbose))
         message("starting umap at ", date())
      basic = irlba::irlba(x, nv=warmdim)$u
      umap::umap(basic, n_components=ncomp)
      },
   TSNE=function(x, ncomp) {
      if (isTRUE(options()$verbose))
         message("starting Rtsne at ", date())
      basic = irlba::irlba(x, nv=warmdim)$u
      Rtsne::Rtsne(basic, dims=ncomp)
     }
    ),
  retrievers = list(
   PPCA = function(x) x$u,
   UMAP = function(x) x$layout,
   TSNE = function(x) x$Y
    )
   )

.checkDefaultProjectors = function(dp) {
  stopifnot(all(names(dp) == c("projectors", "retrievers")))
  prn = names(dp$projectors)
  ren = names(dp$retrievers)
  stopifnot(all.equal(prn,ren))
}

#' add a series of projectors to transformed assay data
#' in a SingleCellExperiment
#' @param sce SingleCellExperiment instance
#' @param ncomp numeric(1) number of components per projection
#' @param tx function that will transform assay quantifications,
#' defaults to `function(x) log(x+1)`
#' @param projectors a list of list of functions like that created
#' @param \dots not used
#' by `defaultProjectors()`
#' @export
addProjections = function(sce, ncomp=4, tx=function(x) log(x+1),
   projectors, ...) {
  stopifnot(is(sce, "SingleCellExperiment"))
  matToUse = t(tx(assay(sce)))
  prs = lapply(projectors$projectors, function(p) 
      p(x=matToUse, ncomp=ncomp))
  ans = lapply(seq_len(length(prs)), function(i) 
    projectors$retrievers[[i]](prs[[i]])
    )
  names(ans) = names(projectors$retrievers)
  ini = reducedDims(sce)
  if (length(ini) == 0) reducedDims(sce) = SimpleList(ans)
  else reducedDims(sce) = c(ini, SimpleList(ans))
  sce
}

#' Define a shiny app for comparing projections
#' @importFrom limma lmFit eBayes topTable
#' @importFrom stats model.matrix
#' @param sce SingleCellExperiment instance with reducedDims populated
#' with various candidates for projection from assay data --
#' @note In sce300xx, names(reducedDims) are 'PC', 'UM', 'TS'
#' for projections generated by
#' irlba::irlba, umap::umap, and Rtsne::Rtsne respectively.  Function
#' will delete .pcmpTab, .pcmpSelNum, .pcmpSelCells from .GlobalEnv
#' if found, so that it can assemble information on selections.
#' @return will return an instance of PcmpSels
#' @export
pcmpApp = function(sce) {
 stores = c(".pcmpTab", ".pcmpSelNum", ".pcmpSelCells")
 sapply(stores, function(x) if(x %in% ls(.GlobalEnv, all.names=TRUE))
    rm(list=x, envir=.GlobalEnv))

  sce$.cellid = colnames(sce)
  rd = reducedDims(sce)
  nrd = names(rd)
  ncomps = vapply(rd, ncol, numeric(1))
  stopifnot(all(ncomps == ncomps[1]))
  ncomp <- ncomps[1]
  discv = discreteColdVars(sce)

# keep in sync with code in inst/app/ui.R
  ui <- fluidPage(
   sidebarPanel(width=2,
     helpText(sprintf("pcmp %s: crosstalk-based interactive graphics \
for dimension reduction in single-cell transcriptomics. \ 
See the 'about' tab for more information.", pkgVersion())),
     selectInput("pickedStrat", "stratby", discv, discv[1]),
     selectInput("meth1", "method left", nrd, nrd[1]),
     selectInput("meth2", "method right", nrd, nrd[2]),
     numericInput("topx", "top x", 1, min=1, max=ncomp-1, step=1),
     numericInput("topy", "top y", 2, min=2, max=ncomp, step=1),
     numericInput("botx", "bot x", 2, min=1, max=ncomp-1, step=1),
     numericInput("boty", "bot y", 3, min=2, max=ncomp, step=1),
     actionButton("btnSend", "Stop app")
     ),
   mainPanel(
    tabsetPanel(
    tabPanel("scatter",
     fluidRow(
       column(6, d3scatterOutput("scatter1")),
       column(6, d3scatterOutput("scatter2"))
       ),
      fluidRow(
       column(6, d3scatterOutput("scatter3")),
       column(6, d3scatterOutput("scatter4"))
       )
     ), # end panel
#    tabPanel("topr3d",
#       scatterplotThreeOutput("try3d")
#     ),
    tabPanel("selTable",
     DT::dataTableOutput("summary")
     ),
    tabPanel("accum",
       helpText("Method and dimensions taken from bottom left panel"),
       plotOutput("accum")
        ),
    tabPanel("about",
     helpText("pcmp is crosstalk-based interactive graphics for surveying different dimension reduction procedures for data in SingleCellExperiment containers.  The reducedDims component must be populated with several reductions, each including at least 4 dimensions.   Different methods are used in the left and right columns, and different projection components can are used in the top and bottom rows, as selected using the method/top/bot controls below.  The ColorBy button will recolor points according to discrete covariates in the colData of the input object."),
     helpText("The initial example uses the Allen Brain Atlas RNA-seq data on anterior cingulate cortex (ACC) and primary visual cortex (VIS) brain regions.  Strata were formed using donor (3 levels) and region (2 levels) and 300 cells were sampled at random in each stratum.")
   )
  )
  )
  ) 
#


server <- function(input, output, session) {
  rd = reducedDims(sce)
  nmeth = length(rd) # list of matrices of projected data
  methnames = names(rd)
  nrd = names(rd)
  ncomps = vapply(rd, ncol, numeric(1))
  stopifnot(all(ncomps == ncomps[1]))  # requires balanced representation 
    # of all projections
  ncomp <- ncomps[1]
  indf = data.frame(do.call(cbind, as.list(rd)))
  cn = paste0(nrd[1], 1:ncomp)
  if (length(nrd) > 1) {
      for (j in 2:length(nrd)) cn = c(cn, paste0(nrd[j], 1:ncomp))
      }
  colnames(indf) = cn
  indf <- as.data.frame(cbind(indf, colData(sce)))
  
  fmlist = lapply(methnames, function(x) list())
  names(fmlist) = methnames
  for (i in 1:nmeth) {
   curtags = paste0(methnames[i], 1:ncomp)
   fmlist[[i]] = lapply(curtags, function(x) as.formula(c("~", x)))
   names(fmlist[[i]]) = curtags
  }
  
  #PCtags = paste0("PC", 1:ncomp)
  #UMtags = paste0("UM", 1:ncomp)
  #TStags = paste0("TS", 1:ncomp)
  #PCfmlas = lapply(PCtags, function(x) as.formula(c("~", x)))
  #UMfmlas = lapply(UMtags, function(x) as.formula(c("~", x)))
  #TSfmlas = lapply(TStags, function(x) as.formula(c("~", x)))
  #names(PCfmlas) = PCtags
  #names(UMfmlas) = UMtags
  #names(TSfmlas) = TStags
  #fmlist = list(PC=PCfmlas, UM=UMfmlas, TS=TSfmlas)

  enhDf = reactive({
   indf$strat = colData(sce)[[input$pickedStrat]]
   indf$key = 1:nrow(indf)
   indf
   })  

  shared_dat <- SharedData$new(enhDf) #enhDf, key=~key)

  output$scatter1 <- renderD3scatter({
    methx = paste0(input$meth1, input$topx)
    methy = paste0(input$meth1, input$topy)
    d3scatter(shared_dat, fmlist[[input$meth1]][[methx]], 
            fmlist[[input$meth1]][[methy]], ~strat, width = "100%")
  })
  output$scatter2 <- renderD3scatter({
    methx = paste0(input$meth2, input$topx)
    methy = paste0(input$meth2, input$topy)
    d3scatter(shared_dat, fmlist[[input$meth2]][[methx]], 
            fmlist[[input$meth2]][[methy]], ~strat, width = "100%")
  })
  output$scatter3 <- renderD3scatter({
    methx = paste0(input$meth1, input$botx)
    methy = paste0(input$meth1, input$boty)
    d3scatter(shared_dat, fmlist[[input$meth1]][[methx]], 
            fmlist[[input$meth1]][[methy]], ~strat, width = "100%")
  })
  output$scatter4 <- renderD3scatter({
    methx = paste0(input$meth2, input$botx)
    methy = paste0(input$meth2, input$boty)
    d3scatter(shared_dat, fmlist[[input$meth2]][[methx]], 
            fmlist[[input$meth2]][[methy]], ~strat, width = "100%")
  })
#  output$try3d <- renderScatterplotThree({
#    colors = palette(rainbow(30))[ as.numeric(
#                      factor(colData(sce)[[input$pickedStrat]])) ]
#    print(head(shared_dat))
#    scatterplot3js(PC1, PC2, PC3, crosstalk=shared_dat, brush=TRUE,
#       color=colors)
#    })
 output$accum = renderPlot({
 ans = list(cells = .GlobalEnv$.pcmpSelCells, limmaTab=.GlobalEnv$.pcmpTab)
 tmp = new("PcmpSels", cellSets=ans$cells, geneTable=ans$limmaTab)
 replay(pcmp::sce300xx, tmp, input$meth1, input$botx, input$boty) 
 })
    

output$summary <- DT::renderDataTable({
    df <- shared_dat$data(withSelection = TRUE) %>%
      filter(selected_ | is.na(selected_)) %>%
      mutate(selected_ = NULL)
    sel=rep(0, ncol(sce))
    names(sel) = colnames(sce)
    sel[df$.cellid] = 1
    mm = stats::model.matrix(~sel, data=data.frame(sel=sel))
   showNotification(paste("starting table processing", date()), id="limnote")
    X = log(assay(sce)+1)
    f1 = limma::lmFit(X, mm)
    ef1 = limma::eBayes(f1)
  print(paste0("finish lmFit", date()))
    options(digits=3)

    tt = limma::topTable(ef1, 2, n=20)
    if (!(".pcmpSelNum" %in% ls(.GlobalEnv, all.names=TRUE))) assign(".pcmpSelNum", 1, .GlobalEnv)
      else assign(".pcmpSelNum", .GlobalEnv$.pcmpSelNum + 1, .GlobalEnv)
    if (!(".pcmpSelCells" %in% ls(.GlobalEnv, all.names=TRUE))) assign(".pcmpSelCells", list(df$.cellid), .GlobalEnv)
      else assign(".pcmpSelCells", c(.GlobalEnv$.pcmpSelCells, list(df$.cellid)), .GlobalEnv)
    tt = cbind(tt, selnum=.GlobalEnv$.pcmpSelNum[1])
    if (!(".pcmpTab" %in% ls(.GlobalEnv, all.names=TRUE))) assign(".pcmpTab", tt, .GlobalEnv)
      else assign(".pcmpTab", rbind(.GlobalEnv$.pcmpTab, tt), .GlobalEnv)
    ans = DT::formatRound(DT::datatable(tt), 1:7, digits=3)
   removeNotification(id="limnote")
    ans
  })

   observe({
                    if(input$btnSend > 0)
                        isolate({
                           stopApp(returnValue=0)
                        })  
           })  
  } # end server
 tmp = runApp(list(ui=ui, server=server))
#
 ans = list(cells = .GlobalEnv$.pcmpSelCells, limmaTab=.GlobalEnv$.pcmpTab)
 new("PcmpSels", cellSets=ans$cells, geneTable=ans$limmaTab)
}

